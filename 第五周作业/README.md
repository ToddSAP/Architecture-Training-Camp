### 测试结果

|服务器数量|虚拟节点数量|缓存数据量|测试次数|哈希算法|标准差中位数|均匀度提升效率(（上层标准差-下层标准差）/ 上层标准差 )
|------|-------|-------|-------|-------|--------|--------|
|10|100|1000000|100|FNV1_32_HASH|9301.9852074705|0|
|10|150|1000000|100|FNV1_32_HASH|9529.120945816565|-2.44%|
|10|200|1000000|100|FNV1_32_HASH|6232.970704246892|34.59%|
|10|300|1000000|100|FNV1_32_HASH|3322.066375014202|46.70%|
|10|500|1000000|100|FNV1_32_HASH|3776.5752210170526|-13.68%|
|10|1000|1000000|100|FNV1_32_HASH|2023.100788393895|46.43%|
|10|2000|1000000|100|FNV1_32_HASH|1918.0522933434322|5.19%|
|10|5000|1000000|100|FNV1_32_HASH|1676.4869817567926|12.59%|
|10|10000|1000000|100|FNV1_32_HASH|922.3554629317267|44.98%|
|10|20000|1000000|100|FNV1_32_HASH|904.5656416203304|1.93%|
||||||
|10|20000|1000000|100|RS_HASH|10213.3811639437|


结论： 
- 缓存负载的均匀程度随虚拟节点增加而提升，但非线性提升。200-300、1000、10000时可能会得到较好的费效比，但需要在不同负载下测试后才能得到印证。  
- 综合业内的实践，200个虚拟节点一般是比较好的选择。  
- 寻找最适合你的虚拟节点个数，首先找到你的系统的最常见的负载，在该负载下测试不同虚拟节点个数下的负载均匀度，最后选择最佳答案。  
- 好的哈希函数非常重要，对比一般的哈希函数，均衡度可能是数量级的提升。  

### 总结

#### 一致性哈希
- 什么是一致性哈希  
    - 一致性哈希算法是一种分布式路由算法，最初的目的是为了解决互联网热点问题，后来被用来解决分布式系统伸缩时的路由问题。  
- 一致性哈希的原理  
    - 一致性哈希利用一个超大的值域(2^32)来容纳所有可能的值，包含请求哈希和服务器哈希。服务器节点和请求都同样在同一环中定位，猜测这应该是"一致性"的由来。    
    - 将服务器节点(真实或虚拟)散列值按升序分布在值域中，好的散列函数可以做到比较均匀的分布。  
    - 一般地，用有序线性表来模拟环，利用有序线性表的快速查找特性(O(logn))来定位到第一个大于自己的服务器节点散列值，则该请求就路由到了这个服务器节点;找不到大于自己的服务器节点，则路由到环的第一个节点。    
- 一致性哈希的应用
    - 一致性哈希一般用于缓存服务器的路由，因为服务器伸缩对于缓存失效率和命中率的影响很大，而一致性哈希可以显著降低这些影响。  
    - 具体上，一致性哈希利用多个服务器虚拟节点均匀分布在环中，将环均匀分割成若干段，每段负责少量缓存值。由于均匀分布，多个真实服务器的虚拟节点可以做到相互交叉排列，当某台服务器故障，其所有虚拟节点失效后，其每个虚拟节点的负载将会转移到顺时针的临近节点，故转移后环上每个虚拟节点的负载仍是均匀。  
- 一致性哈希的实现  
    - 需要找一种有序线性数据结构作为环，这种数据结构的插入和查找性能都要比较好。在Java中，TreeMap满足所有条件，是理想选择。如果不用Treemap，LinkedHashMap满足性能要求但无序；数组满足有序和随机查找性能要求但插入性能不好；单链表满足有序和插入性能要去但随机查找性能不好。
    - 可以自己用数组实现一个二叉查找树，插入、随机查找都是O(logn)，中序遍历存储做到有序，但数组扩容的天然缺陷会在节点变更时导致数据迁移，影响性能，由于现实中节点不会频繁变更，故问题不大。此外，该方案不能解决数据偏斜问题，需要好的哈希算法来规避。  
    - 构造好了上述结构，则路由算法相对简单，只需在找key哈希值对应的临近服务器虚拟节点即可。需要注意的是，查找到了环尾需重新定位到环头。  
    
    
#### 异步  
- 什么是异步  
    - 异步是相对同步来讲，同步模式下，线程需等待且主动获取任务执行结果，而异步模式下，线程无需等待任务执行结果且执行结果会被系统推送给线程，无需线程自己获取。  
- 异步的好处  
    - 无需等待任务执行结果，减少了线程等待造成的CPU时间片占用，提升了系统的吞吐量。  
    - 无需主动获取任务执行结果，减少了对任务执行者的依赖，实现了解耦。  
- 异步的适用场景  
    - 无需数据强一致性的场景皆适用，如发账户注册成功通知邮件、发送通知短息、提交报表生成请求、写日志等。  
- 异步的实现  
    - 点对点消息  
        - 消息被消费一次后就没了。  
        - 适合单消费者场景，无法扩展消费者。  
    - 消息队列
        - 消息可被多次消费，消息是持久化的。  
        - 时候多消费者场景，对消费者扩展友好。  
    - 回调  
        - 适合需要获取任务执行结果的场景。当任务执行结束，系统会调用线程的回调方法，完成后续的任务处理。  
        - 观察者模式的实现就是基于回调。观察者实现了回调接口，且订阅了被观察者，当被观察者变化时，被观察者调用观察者的回调接口函数完成对观察者的通知。  


#### 负载均衡  
- 什么是负载均衡  
    - 负载均衡是在集群环境下均匀分配负载的过程。  
- 负载均衡的要点  
    - 需要将负载均匀分配给每台服务器，而且是在服务器数量可以变化的情况下，不能由明显的偏斜或分配给失效服务器。  
    - 均衡负载的过程开销要小，不能占用过多时间。  
- 负载均衡的实现  
    - 转发方式  
        - HTTP重定向 
            - 负载均衡服务器返给请求方具体应用服务器的地址，由请求方重新请求应用服务器。  
            - 暴露了应用服务器地址，对安全性不友好。   
            - 每次都会多一次额外的比较昂贵的HTTP请求，开销比较大。           
            - 目前采用的较少。  
        - DNS   
            - 比较好的一级负载均衡，但客户端可能有DNS解析后的IP缓存，如果IP宕机，则会有不可用的时间窗口。  
        - 反向代理  
            - 需要转发HTTP请求，开销较大，对于大量服务器，则反向代理本身可能会成为单点。  
            - 对于服务器数量不大的系统比较适用。 
        - IP   
            - 修改TCP数据包中的目标地址来达到直接转发的效果。  
            - 返回时也需要IP代理服务器转发，网卡出口带宽开销较大，可能成为瓶颈。  
        - 链路层  
            - 修改目标MAC地址来达到直接转发的效果。  
    - 均衡算法  
        - 轮询   
            - 所有请求依次被分发到各个服务器，适合每台服务器的服务能力都相同的场景。  
        - 加权轮询
            - 根据服务器的硬件配置情况，在轮询基础上，根据权重来分发请求。高性能的服务器能被分发到更多的请求。  
        - 随机 
            - 适合大部分场景，随机本身就很均衡，也可以根据硬件情况使用加权随机。   
        - 最少连接  
            - 将新请求分发到连接最少的服务器。但连接最少不意味着负载最小，可能少量连接都在处理重IO等，故不是很好的选择。  
        - 源地址散列  
            - 根据IP地址散列来选择服务器，可实现会话粘滞。对于伸缩性不友好，已被淘汰。  
            
        