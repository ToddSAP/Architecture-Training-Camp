## 作业1. 导致系统不可用的原因有哪些？保障系统稳定高可用的方案有哪些？请分别列举并简述。  
系统不可用的原因及解决方案：  
- 并发请求超过系统负载上限，导致系统资源耗尽，引发请求无响应。可通过分布式系统的水平扩容来提升整体的服务能力上限，来提升并发处理能力。或者通过消息队列削峰填谷，异步处理请求，维持系统资源一直可用。  
- 硬件设备故障，导致服务下线，引发请求无法响应。可通过双主、主从、集群部署等热备方案来提升系统的容灾能力，来规避硬件故障时的系统可用性问题。  
- 数据传输能力达到上限，导致请求处理时间过长或超时。可在热点地区增加数据中心来减少数据传输量，来减少整体请求处理时长。  
- 存在服务单点瓶颈，如每次请求都访问数据库，数据库就是服务单点瓶颈，会导致请求处理时间延长，影响整体吞吐量。可将热点数据放到缓存，或增加反向代理，减少数据库等重量级调用，来减少请求处理时长。  
- 前端需要加载的资源过多，导致UI渲染时间较长，影响用户UI的可用性。可通过增加CDN来缓存静态资源，提升UI资源加载速度，减少用户UI的渲染时长。  
- 

  
     


## 作业2. 编写一个用户密码验证函数。   
[校验函数](password/PasswordValidation.java)  
[测试入口](password/client/PasswordClient.java)  
[RSA实现](password/encryption/RSAStrategy.java)  
[MD5实现](password/encryption/MD5Strategy.java)  
测试结果   
```java
RSA加密密码：33022148541136451720708545761868049355542776669333204796301557288509253055521374119757004364145849831574902349232864144092122693154056266739717959082193754514489841318730545807723082032692464698931906188868059596839809389540843532883163093590048563276996973628434078715723278128629798777653579003818827790304
RSA密码验证失败
MD5加密密码:895340303c0b24b684f4bc44de2d342e
MD5密码验证成功！
```


## 总结  
加密是安全性的重要组成部分，第二个作业也说明了问题。自己在之前也整理过加密的相关内容，这里再梳理下。  
加密技术可分成"对称式"和"非对称式"两种。其中"对称式"指的是加解密都用同一套密钥，而"非对称式"是指加解密使用不同的密钥，这需要从这两种加密方式的由来和使用场景说起。  
最开始的加密，就是简单的字符位移，如"abc"替换成"zyx"，替换的规则就记录在密码表上，有了密码表就可以解码。当然，这种简单的加密有个致命的缺点，就是一旦密码表泄露，那么所有加密过的密码瞬间都变成了明文，而且西方字母个数有限，可以暴力破解。这时的加密思路核心就是替换规则，主要的手段也就是保证替换规则不泄露，这种加密方式在民用上还行，但在军用上则越来越无法保密了。  
随着二进制的发明，人们发现可以用一串二进制串和明文的二进制串做运算来加解密，而用来加密的二进制串可以很长，组合数量也是天文数字，大大增加了破解的难度，于是流加密诞生了，而用来加密的二进制串也被称为密钥。  
最开始的流加密是用密钥直接对整个明文运算加密，但后来发现这样一旦密钥泄露，则密码直接就被破解，分组加密随之出现。分组就是将明文分成若干组二进制串，每组使用不同的密钥运算规则来产生密文串，这样即使密钥泄露，也必须知道每组的运算规则才能破解，成倍增加了破解的难度。DES、AES等都是此类加密。但流加密还是存在密钥泄露而被破解的隐患，因为密钥需要传输给加密者以给明文加密，在传输的过程中可能被拦截。那么有没有不需要传输的密钥呢？  
非对称加密就是加密使用公钥，解密使用私钥，公钥可以传输给加密者，而私钥存放在解密者侧，不需要传输。即使公钥被拦截破解，那也只能伪造密文，没有私钥是破解不了密文的。RSA、DSA、ECC都是此类算法。理论上，私钥只要不主动泄露，密码是不会被破解的。  
既然非对称加密的保密程度高，那么是否只要加密就用这种加密方式呢？不然，选择加密方式还要从几个维度来评估。  
选择加密方式的维度：  
- 安全性  
毋庸置疑，安全性是加密的最终目的，容易被破解的加密方式肯定不可取，但也适度即可，理论上10万年可以暴力破解的加密方式和100万年的对我们来说几乎没区别，不是吗？  
- 加密速度  
信息时代的数据是爆炸性的，需要加密的数据量非常大，加密的速度也是重要考量。而加密速度和安全性往往是互斥的，即越安全的加密方式的加密速度越慢，我们要分场景选择。如银行密码、商业机密等重要数据需要安全性高的加密方式，速度慢点就慢点了。而个人简介等不那么重要的数据，可以选择速度快的加密方式。  
- 应用场景  
一般来说，保密要求高的数据要用安全性高的加密算法，加密速度可以被权衡；而不敏感的数据可以选择加密速度快的算法，安全性可以被权衡。  
拿银行密码为例，应该使用摘要算法加密，因为摘要算法不能反推出明文，故安全性高。  



除了上述两种加密方式，还有一种就是哈希算法，即将任意多的字符映射到固定长度的字符。哈希算法属于摘要算法的一种，即取原文中若干字符进过运算后得到另一个字符串。哈希算法不可逆，无法从摘要后的字符串反推出原文，一般用来做数字签名。  
最后总结一下常用的加密算法：  
- DES (Data Encryption Standard):  
  对称加密算法，早期美国的数据加密标准，速度较快，但近年已被破解，不再建议使用。  
- AES (Advanced Encryption Standard):  
  对称加密算法，高级加密标准，速度快，安全性高。AES是分组加密算法，分组块可使用128、192或256位的密钥，对4x4的字节数组进行运算，结合专用硬件，可以实现达十亿bit量级/秒的加解密吞吐量。  
- RSA：
  非对称加密算法，支持变长公钥。原理是利用质因数分解非常耗时来保证安全性，通过大质数的乘方和模运算来加解密。算法本身非常简单，就是乘方和模运算，只需要选定符合规则的质数，即可完成加解密，非常高效。是目前公认且广泛使用的加密算法。  
- MD5 (Message Digest)：  
  散列也即摘要算法，只能单向生成，不可解码。原理是将明文映射到固定长度的字符串。被广泛用于数字签名和密码校验等认证功能。  
- SHA (Secure Hash Algorithm):  
  和MD5一样，也是摘要/哈希算法，不可解码。原理是对摘要数据进行80轮异或运算，使得混淆充分。摘要选取的长度也有160、224、256和512之选，摘要数据越长，安全性越好，但运算速度越慢。应用的场景和MD5类似。  


今天把老师的视频看了一遍，有了些新的认识，如下。  
安全攻击：
- XSS： 
在防御时，通过消毒来转义脚本关键字符。  
- SQL注入： 
攻击者传入恶意的删除表或其他不被期望的SQL片段，使得服务器在执行整个SQL时，除了执行期望中的SQL外，还执行了不被期望的SQL，造成数据丢失或损坏。  
在防御时，可以通过消毒来检测恶意关键字。或者使用绑定变量来规避恶意语句。  
- CSRF:  
攻击者伪造访问者，向服务器发起恶意请求。如在访问者登录某购物网站时，伪造访问者，向购物网站发起购物请求。  
在防御时，在服务端可用token来验证请求是否真实由访问者发起。还可用验证码来验证是否真实请求，因为劫持者往往不能访问真实的网页，无法获得验证码。  
- Error Code:   
不要将异常堆栈信息直接抛给用户，而应该抛出友好的错误和提示。  
- 文件上传：  
指定可上传文件的类型，对文件名称转义。  
- 路径遍历：  
可不将访问路径暴露给用户，可在服务器端转换真实的访问路径。  


